<!DOCTYPE html>
<html>

<head>
    <title>AR.js Interactive Bed with User Uploaded Image Texture</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@latest/aframe/build/aframe-ar.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        a-scene {
            height: 100vh;
        }

        #arjsDebugUIContainer {
            display: none !important;
        }

        .a-enter-vr-button,
        .a-modal {
            display: none !important;
        }

        #file-input {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <input type="file" id="file-input" accept="image/*">

    <a-scene embedded arjs id="scene">
        <a-assets>
            <img id="bedTexture" crossorigin="anonymous" />

            <img id="bedsheetTexture" src="https://jsaad-syncoms.github.io/ar3/pexels-anniroenkae-2860804.jpg"
                crossorigin="anonymous" />
        </a-assets>

        <a-entity id="bed" position="0 0 -10" rotation="15 0 0" scale="0.5 0.5 0.5">
            <!-- Bed Frame -->
            <a-box position="0 0.25 0" depth="8" height="0.5" width="5" material="color: #5a3a3a;"></a-box>
            <!-- Mattress -->
            <a-box id="mattress" position="0 0.75 0" depth="7.8" height="0.5" width="4.8"
                material="src: #bedTexture; color: white; repeat: 1 1; offset: 0 0;"></a-box>
            <!-- Bedsheet -->
            <a-plane id="bedsheet" position="0 1.75 1.9" rotation="-90 -90 90" width="4.5" height="6.8"
                material="src: #bedsheetTexture; repeat: 1 1; transparent: true;" geometry=""></a-plane>
            <!-- Headboard -->
            <a-box position="0 1.5 -3.4" depth="0.2" height="1" width="4.8" material="color: #5a3a3a;"></a-box>
        </a-entity>

        <a-nft type="nft" url="https://jsaad-syncoms.github.io/ar3/nft/" smooth="true" smoothCount="10"
            smoothTolerance="0.01" smoothThreshold="5">
            <a-entity position="0 0 0" scale="0.05 0.05 0.05">
                <a-box position="0 0.25 0" depth="1" height="0.5" width="2" material="color: brown;"></a-box>
                <a-box position="0 0.75 0" depth="1" height="0.5" width="2" material="color: lightgrey;"></a-box>
                <a-box position="0 1.0 0.45" depth="0.1" height="0.5" width="2" material="color: lightgrey;"></a-box>
            </a-entity>
        </a-nft>
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const fileInput = document.getElementById('file-input');
            const bedTexture = document.getElementById('bedTexture');
            const bedsheetTexture = document.getElementById('bedsheetTexture');
            const bed = document.getElementById('bed');
            const mattress = document.getElementById('mattress');
            const bedsheet = document.getElementById('bedsheet');
            let isDragging = false;
            let isResizing = false;
            let startPosition = { x: 0, y: 0 };
            let startScale = 0.5;
            let initialDistance = 0;
            let initialScale = 0.5;

            fileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                console.log('File selected:', file);
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        console.log('FileReader loaded:', e.target.result);
                        // Set the texture src attribute
                        bedsheetTexture.setAttribute('src', e.target.result);

                        // Update the mattress material after the texture is loaded
                        bedsheetTexture.onload = function () {
                            console.log('Texture loaded:', bedsheetTexture.getAttribute('src'));
                            // Force re-render by setting material to a blank value then back to the texture
                            bedsheet.setAttribute('material', 'src: ');
                            setTimeout(() => {
                                bedsheet.setAttribute('material', 'src: #bedsheetTexture; color: white; repeat: 1 1; offset: 0 0;');
                                console.log('Mattress material updated:', mattress.getAttribute('material'));
                            }, 0);
                        };
                    };
                    reader.readAsDataURL(file);
                    console.log('FileReader reading as DataURL');
                }
            });

            const scene = document.getElementById('scene');

            scene.addEventListener('mousedown', function (event) {
                if (event.button === 0) { // Left mouse button
                    isDragging = true;
                    startPosition = { x: event.clientX, y: event.clientY };
                    event.preventDefault();
                }
            });

            scene.addEventListener('mousemove', function (event) {
                if (isDragging) {
                    const dx = event.clientX - startPosition.x;
                    const dy = event.clientY - startPosition.y;
                    const newPosition = { x: bed.object3D.position.x + dx * 0.01, y: bed.object3D.position.y - dy * 0.01 };
                    bed.object3D.position.set(newPosition.x, newPosition.y, bed.object3D.position.z);
                    startPosition = { x: event.clientX, y: event.clientY };
                }
            });

            scene.addEventListener('mouseup', function () {
                isDragging = false;
            });

            scene.addEventListener('wheel', function (event) {
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                startScale = Math.max(0.1, startScale + delta);
                bed.setAttribute('scale', `${startScale} ${startScale} ${startScale}`);
            });

            scene.addEventListener('touchstart', function (event) {
                if (event.touches.length === 1) {
                    isDragging = true;
                    startPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                if (event.touches.length === 2) {
                    isResizing = true;
                    initialDistance = Math.sqrt(
                        Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
                        Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
                    );
                    initialScale = startScale;
                }
                event.preventDefault();
            });

            scene.addEventListener('touchmove', function (event) {
                if (isDragging && event.touches.length === 1) {
                    const dx = event.touches[0].clientX - startPosition.x;
                    const dy = event.touches[0].clientY - startPosition.y;
                    const newPosition = { x: bed.object3D.position.x + dx * 0.01, y: bed.object3D.position.y - dy * 0.01 };
                    bed.object3D.position.set(newPosition.x, newPosition.y, bed.object3D.position.z);
                    startPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                if (isResizing && event.touches.length === 2) {
                    const currentDistance = Math.sqrt(
                        Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
                        Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
                    );
                    const scaleChange = currentDistance / initialDistance;
                    startScale = Math.max(0.1, initialScale * scaleChange);
                    bed.setAttribute('scale', `${startScale} ${startScale} ${startScale}`);
                }
            });

            scene.addEventListener('touchend', function (event) {
                if (event.touches.length === 0) {
                    isDragging = false;
                    isResizing = false;
                }
            });
        });
    </script>
</body>

</html>