<!DOCTYPE html>
<html>

<head>
    <title>AR.js Interactive Bed with User Uploaded Image Texture</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@latest/aframe/build/aframe-ar.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        a-scene {
            /* width: 100vw; */
            height: 100vh;
        }

        #arjsDebugUIContainer {
            display: none !important;
        }

        .a-enter-vr-button,
        .a-modal {
            display: none !important;
        }

        #file-input {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: none;
        }

        .upload-icon {
            width: 50px;
            height: 50px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .icon-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }

        #ar-preview {
            /* width: 100vw; */
            height: 100vh;
        }

        /* canvas {
            width: 100vw !important;
            height: 100vh;
        } */

        #container {
            width: 200vw;
            height: 100vh;
            overflow: hidden;
        }

        #create {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0px;
            left: 100vw;
            /* left: 0; */
            z-index: 2;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 300ms ease-in-out;
        }

        #cropper {
            width: 300px;
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #apply-crop,
        #set-texture {
            display: none;
        }

        .toggle {
            position: fixed;
            top: 50px;
            left: 0;
            z-index: 3;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <!-- <div id="container"> -->
    <!-- <div id="ar-preview"> -->
    <!-- <input type="file" id="file-input" accept="image/*"> -->
    <div class="toggle">
        <button id="preview">Preview</button>
        <button id="edit">Create</button>
    </div>

    <a-scene embedded arjs id="scene">
        <a-assets>
            <!-- <img id="bedTexture" crossorigin="anonymous" /> -->

            <img id="bedsheetTexture" src="https://jsaad-syncoms.github.io/ar3/pexels-anniroenkae-2860804.jpg"
                crossorigin="anonymous" />
            <!-- <img id="wrinkleMap" src="https://jsaad-syncoms.github.io/ar3/fabric_0032_height_1k.png"
                    crossorigin="anonymous" /> -->
        </a-assets>

        <a-entity id="bed" position="0 0 -10" rotation="15 0 0" scale="0.5 0.5 0.5">
            <!-- Bed Frame -->
            <a-box position="0 0.25 0" depth="8" height="0.5" width="5" material="color: #5a3a3a;"></a-box>
            <!-- Mattress -->
            <a-box id="mattress" position="0 0.75 0" depth="7.8" height="0.5" width="4.8"
                material="src: ; color: white; repeat: 1 1; offset: 0 0;"></a-box>
            <!-- Bedsheet -->
            <a-plane id="bedsheet" position="0 1.75 1.9" rotation="-90 -90 90" width="4.5" height="6.8"
                material="src: #bedsheetTexture; repeat: 1 1; transparent: true;" geometry=""></a-plane>
            <!-- Headboard -->
            <a-box position="0 1.5 -3.4" depth="0.2" height="1" width="4.8" material="color: #5a3a3a;"></a-box>
        </a-entity>

        <a-nft type="nft" url="https://jsaad-syncoms.github.io/ar3/nft/" smooth="true" smoothCount="10"
            smoothTolerance="0.01" smoothThreshold="5">
            <a-entity position="0 0 0" scale="0.05 0.05 0.05">
                <a-box position="0 0.25 0" depth="1" height="0.5" width="2" material="color: brown;"></a-box>
                <a-box position="0 0.75 0" depth="1" height="0.5" width="2" material="color: lightgrey;"></a-box>
                <a-box position="0 1.0 0.45" depth="0.1" height="0.5" width="2" material="color: lightgrey;"></a-box>
            </a-entity>
        </a-nft>
        <a-entity camera></a-entity>
    </a-scene>

    <div id="create">
        <!-- <input type="file" id="file-input" accept="image/*"> -->
        <div class="icon-container">
            <svg id="upload-icon" class="upload-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path
                    d="M12 16c-.256 0-.512-.098-.707-.293l-4-4c-.391-.391-.391-1.023 0-1.414.391-.391 1.023-.391 1.414 0L11 12.586V3c0-.553.447-1 1-1s1 .447 1 1v9.586l2.293-2.293c.391-.391 1.023-.391 1.414 0 .391.391.391 1.023 0 1.414l-4 4c-.195.195-.451.293-.707.293z" />
                <path d="M20 19H4c-.553 0-1-.447-1-1s.447-1 1-1h16c.553 0 1 .447 1 1s-.447 1-1 1z" />
            </svg>
            <input type="file" id="file-input" accept="image/*">
        </div>
        <div class="controls">
            <canvas id="cropper"></canvas>
            <input type="range" id="zoom-slider" min="0.5" max="3" step="0.1" value="1">
            <button id="apply-crop">Apply Crop</button>
            <button id="set-texture">Set Texture</button>
        </div>
    </div>
    <!-- </div> -->
    <!-- </div> -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const preview = document.getElementById('preview');
            const edit = document.getElementById('edit');

            const uploadIcon = document.getElementById('upload-icon');
            const fileInput = document.getElementById('file-input');
            const bedTexture = document.getElementById('bedTexture');
            const bedsheetTexture = document.getElementById('bedsheetTexture');
            const bed = document.getElementById('bed');
            const mattress = document.getElementById('mattress');
            const bedsheet = document.getElementById('bedsheet');

            const canvas = document.getElementById('cropper');
            const ctx = canvas.getContext('2d');
            const zoomSlider = document.getElementById('zoom-slider');
            const applyCropButton = document.getElementById('apply-crop');
            const setTextureButton = document.getElementById('set-texture');

            let img = new Image();
            let scale = 1;
            let offsetX = 0;
            let offsetY = 0;
            let isDraggingCropper = false;
            let startX = 0;
            let startY = 0;
            let minScale = 1;

            let isDragging = false;
            let isResizing = false;
            let startPosition = { x: 0, y: 0 };
            let startScale = 0.5;
            let initialDistance = 0;
            let initialScale = 0.5;

            fileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                // console.log('File selected:', file);
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        // console.log('FileReader loaded:', e.target.result);
                        // Set the texture src attribute
                        bedsheetTexture.setAttribute('src', e.target.result);

                        // Update the mattress material after the texture is loaded
                        bedsheetTexture.onload = function () {
                            // console.log('Texture loaded:', bedsheetTexture.getAttribute('src'));
                            // Force re-render by setting material to a blank value then back to the texture
                            bedsheet.setAttribute('material', 'src: ');
                            setTimeout(() => {
                                bedsheet.setAttribute('material', 'src: #bedsheetTexture; color: white; repeat: 1 1; offset: 0 0;');
                                // console.log('Mattress material updated:', mattress.getAttribute('material'));
                            }, 0);
                        };
                    };
                    reader.readAsDataURL(file);
                    // console.log('FileReader reading as DataURL');
                }
            });

            // Offscreen canvas for resizing image
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d');

            function drawImage() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0);
                ctx.restore();
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(value, max));
            }

            // function constrainOffsets() {
            //     const imgWidth = img.width * scale;
            //     const imgHeight = img.height * scale;

            //     const maxOffsetX = Math.max(0, (canvas.width - imgWidth) / 2);
            //     const minOffsetX = Math.min(0, (canvas.width - imgWidth) / 2);
            //     const maxOffsetY = Math.max(0, (canvas.height - imgHeight) / 2);
            //     const minOffsetY = Math.min(0, (canvas.height - imgHeight) / 2);

            //     offsetX = clamp(offsetX, minOffsetX, maxOffsetX);
            //     offsetY = clamp(offsetY, minOffsetY, maxOffsetY);
            // }

            function constrainOffsets() {
                const imgWidth = img.width * scale;
                const imgHeight = img.height * scale;

                // Prevent image from moving out of canvas
                offsetX = clamp(offsetX, canvas.width - imgWidth, 0);
                offsetY = clamp(offsetY, canvas.height - imgHeight, 0);
            }

            function initializeCanvas() {
                ctx.fillStyle = "grey";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "white";
                ctx.font = "20px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("UPLOAD YOUR PHOTO", canvas.width / 2, canvas.height / 2);
            }

            // Initialize canvas on load
            initializeCanvas();

            // Handle image upload
            fileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        img.src = e.target.result;
                        img.onload = function () {
                            // Resize the image if it's too large
                            const maxDimension = 1024; // Maximum width or height
                            if (img.width > maxDimension || img.height > maxDimension) {
                                const aspectRatio = img.width / img.height;
                                if (img.width > img.height) {
                                    offscreenCanvas.width = maxDimension;
                                    offscreenCanvas.height = maxDimension / aspectRatio;
                                } else {
                                    offscreenCanvas.height = maxDimension;
                                    offscreenCanvas.width = maxDimension * aspectRatio;
                                }
                                offscreenCtx.drawImage(img, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
                                img.src = offscreenCanvas.toDataURL();
                            }

                            canvas.width = img.width;
                            canvas.height = img.height;
                            offsetX = (canvas.width - img.width * minScale) / 2;
                            offsetY = (canvas.height - img.height * minScale) / 2;

                            // Set minimum scale so the image is never smaller than the canvas
                            const scaleX = canvas.width / img.width;
                            const scaleY = canvas.height / img.height;
                            minScale = Math.max(scaleX, scaleY);
                            scale = minScale;
                            zoomSlider.min = minScale;
                            zoomSlider.value = minScale;

                            drawImage();
                            setTimeout(() => {
                                setTextureButton.click()
                            }, 500);
                        };
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Zoom slider
            zoomSlider.addEventListener('input', function () {
                scale = parseFloat(zoomSlider.value);
                constrainOffsets();
                drawImage();
                setTimeout(() => {
                    setTextureButton.click()
                }, 500);
            });

            // Mouse events for dragging
            canvas.addEventListener('mousedown', function (e) {
                isDraggingCropper = true;
                startX = e.offsetX;
                startY = e.offsetY;
            });

            canvas.addEventListener('mousemove', function (e) {
                if (isDraggingCropper) {
                    const dx = e.offsetX - startX;
                    const dy = e.offsetY - startY;
                    startX = e.offsetX;
                    startY = e.offsetY;
                    offsetX += dx;
                    offsetY += dy;
                    constrainOffsets();
                    drawImage();

                }
            });

            canvas.addEventListener('mouseup', function () {
                isDraggingCropper = false;
            });

            canvas.addEventListener('mouseleave', function () {
                isDraggingCropper = false;
                setTimeout(() => {
                    setTextureButton.click()
                }, 500);
            });

            // Touch events for dragging
            canvas.addEventListener('touchstart', function (e) {
                console.log('start dragging', 1);
                if (e.touches.length === 1) {
                    console.log('start dragging', 2);
                    isDraggingCropper = true;
                    const touch = e.touches[0];
                    // startX = touch.clientX - canvas.getBoundingClientRect().left;
                    // startY = touch.clientY - canvas.getBoundingClientRect().top;
                    startX = touch.pageX - offsetX;
                    startY = touch.pageY - offsetY;
                    e.preventDefault();
                }
            });

            canvas.addEventListener('touchmove', function (e) {
                console.log('dragging', 1);
                if (isDraggingCropper && e.touches.length === 1) {
                    console.log('dragging', 2);
                    const touch = e.touches[0];
                    // const dx = (touch.clientX - canvas.getBoundingClientRect().left) - startX;
                    // const dy = (touch.clientY - canvas.getBoundingClientRect().top) - startY;
                    // startX = touch.clientX - canvas.getBoundingClientRect().left;
                    // startY = touch.clientY - canvas.getBoundingClientRect().top;
                    // offsetX += dx;
                    // offsetY += dy;
                    offsetX = touch.pageX - startX;
                    offsetY = touch.pageY - startY;
                    constrainOffsets();
                    drawImage();
                    e.preventDefault();
                }

            });

            canvas.addEventListener('touchend', function () {
                isDraggingCropper = false;
                setTimeout(() => {
                    setTextureButton.click()
                }, 500);
            });

            // Apply crop
            applyCropButton.addEventListener('click', function () {
                const croppedImage = document.createElement('canvas');
                const croppedCtx = croppedImage.getContext('2d');
                croppedImage.width = cropWidth;
                croppedImage.height = cropHeight;
                croppedCtx.drawImage(canvas, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
                const croppedDataURL = croppedImage.toDataURL();
                bedsheetTexture.setAttribute('src', croppedDataURL);
            });

            // Set texture
            setTextureButton.addEventListener('click', function () {
                // Set the base64 data URL as the texture for the bedsheet
                const dataURL = canvas.toDataURL();
                bedsheetTexture.setAttribute('src', dataURL);

                // Update the mattress material after the texture is loaded
                bedsheetTexture.onload = function () {
                    // console.log('Texture loaded:', bedsheetTexture.getAttribute('src'));
                    // Force re-render by setting material to a blank value then back to the texture
                    bedsheet.setAttribute('material', 'src: ');
                    setTimeout(() => {
                        bedsheet.setAttribute('material', 'src: #bedsheetTexture; color: white; repeat: 1 1; offset: 0 0;');
                        // console.log('Mattress material updated:', mattress.getAttribute('material'));
                    }, 0);
                };
            });

            preview.addEventListener("click", () => {
                document.getElementById("create").removeAttribute("style");
            });

            edit.addEventListener("click", () => {
                document.getElementById("create").setAttribute("style", "left: 0");
            })

            // Handle upload icon click
            uploadIcon.addEventListener('click', function () {
                fileInput.click();
            });

            const scene = document.getElementById('scene');

            scene.addEventListener('mousedown', function (event) {
                if (event.button === 0) { // Left mouse button
                    isDragging = true;
                    startPosition = { x: event.clientX, y: event.clientY };
                    event.preventDefault();
                }
            });

            scene.addEventListener('mousemove', function (event) {
                if (isDragging) {
                    const dx = event.clientX - startPosition.x;
                    const dy = event.clientY - startPosition.y;
                    const newPosition = { x: bed.object3D.position.x + dx * 0.01, y: bed.object3D.position.y - dy * 0.01 };
                    bed.object3D.position.set(newPosition.x, newPosition.y, bed.object3D.position.z);
                    startPosition = { x: event.clientX, y: event.clientY };
                }
            });

            scene.addEventListener('mouseup', function () {
                isDragging = false;
            });

            scene.addEventListener('wheel', function (event) {
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                startScale = Math.max(0.1, startScale + delta);
                bed.setAttribute('scale', `${startScale} ${startScale} ${startScale}`);
            });

            scene.addEventListener('touchstart', function (event) {
                if (event.touches.length === 1) {
                    isDragging = true;
                    startPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                if (event.touches.length === 2) {
                    isResizing = true;
                    initialDistance = Math.sqrt(
                        Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
                        Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
                    );
                    initialScale = startScale;
                }
                event.preventDefault();
            });

            scene.addEventListener('touchmove', function (event) {
                if (isDragging && event.touches.length === 1) {
                    const dx = event.touches[0].clientX - startPosition.x;
                    const dy = event.touches[0].clientY - startPosition.y;
                    const newPosition = { x: bed.object3D.position.x + dx * 0.01, y: bed.object3D.position.y - dy * 0.01 };
                    bed.object3D.position.set(newPosition.x, newPosition.y, bed.object3D.position.z);
                    startPosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                if (isResizing && event.touches.length === 2) {
                    const currentDistance = Math.sqrt(
                        Math.pow(event.touches[0].clientX - event.touches[1].clientX, 2) +
                        Math.pow(event.touches[0].clientY - event.touches[1].clientY, 2)
                    );
                    const scaleChange = currentDistance / initialDistance;
                    startScale = Math.max(0.1, initialScale * scaleChange);
                    bed.setAttribute('scale', `${startScale} ${startScale} ${startScale}`);
                }
            });

            scene.addEventListener('touchend', function (event) {
                if (event.touches.length === 0) {
                    isDragging = false;
                    isResizing = false;
                }
            });
        });
    </script>
</body>

</html>